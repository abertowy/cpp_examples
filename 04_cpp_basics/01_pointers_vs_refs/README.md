pointers vs reference argument passing
======================================
  
В С++ указатель и ссылка – разные вещи, хотя обе могут указывать на ячейку памяти. Основное отличие в том, что ссылка всегда должна быть инициализирована и не может быть изменена, чтобы указывать на другой объект, тогда как указатель может быть переназначен, а также может указывать на nullptr
  
Общее понятие указателя - это нечто, что позволяет нам ссылаться на объект и получать к нему доступ в соответствии с его типом.  
`T*`		        Встроенный тип указателя: указывает на объект типа T или к непрерывно-аллоцированной последовательности элементов типа T  
`T&`		        Встроенный ссылочный тип: ссылается на объект типа T; указатель с неявным разыменованием  
`unique_ptr<T>` 	Владеющий указатель на T  
`shared_ptr<T>` 	Указатель на объект типа T; право собственности распределяется между всеми shared_ptr на этот T  
`weak_ptr<T>` 	Указатель на объект, принадлежащий shared_ptr; должен быть преобразован в shared_ptr для доступа к объекту  
  
- Когда мы совместно используем объект, нам нужны указатели (или ссылки) для ссылки на общий объект, поэтому shared_ptr становится очевидным выбором (если только нет очевидного единственного владельца).  
- Когда мы ссылаемся на полиморфный объект в классическом объектно-ориентированном коде (§5.5), нам нужен указатель (или ссылка), потому что мы не знаем точный тип объекта, на который ссылаемся (или даже его размер), поэтому очевидным выбором становится unique_ptr.  
- Для общего полиморфного объекта обычно требуется shared_ptr.  
- Нам не нужно использовать указатель для возврата коллекции объектов из функции; контейнер, который является дескриптором ресурса, сделает это просто и эффективно, полагаясь на исключение копирования и семантику перемещения  
  
```
Circle a1[10];
array<Circle,10> a2;
Shape* p1 = a1;		// OK: disaster waiting to happen
Shape* p2 = a2;		// error: no conversion of array<Circle,10> to Shape* -> OK
p1[3].draw();		// disaster -> incorrect padding
```